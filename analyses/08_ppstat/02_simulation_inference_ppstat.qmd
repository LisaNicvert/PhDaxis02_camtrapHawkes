---
title: "Simulate and infer interactions with ppstat"
author: 
  name: "Lisa Nicvert"
  orcid: 0009-0006-5763-0865
date: today
format: 
  html:
    toc: true
    toc-depth: 3
embed-resources: true
editor: source
---

## Load libraries

```{r}
#| code-fold: true
#| message: false
library(ppstat)
library(here)

library(lubridate)
library(dplyr)
library(stringr)

library(tidygraph)
library(igraph)

library(patchwork)
library(ggtext)

library(camtrapHawkes)
```

## Parameters

```{r}
set.seed(42)

# Model ------
nspecies <- 5


duration_days <- 2 # interaction function support (A in ppstat framework)
stepfunc <- 0.005

spont <- log(0.1) # Background rate
strength <- log(3) # Max strength of the interaction function

t <- 0.5 # half life for the exponential interaction function

# Simulation params -----
n_cameras <- 25 # number of cameras
Tmax <- 300 # total number of trapping days

nrep_each <- 100 # repeat each simulation x times

# Inference parameters ---
# Inference
ndays <- 1.5 # support of interaction function
phi <- "log" # shape of excitation function

# Model
# Splines basis
Nbasis <- 200 # number of spline basis -> controls "bins width" together with knots

# Species
startknot_spp <- -0.5 # first knot
endknot_spp <- ndays # last knot
by_spp <- 6/24 # knots spacing (in days)
ord <- 4 # order of splines (degree <- ord-1)
trunc <- NULL # truncate? (avoid edge effects)

# --- Figures
figures_path <- here("figures/08_ppstat")

# --- Perform simu and inference
perform_simu <- FALSE
simu_file <- here("outputs/08_ppstat/simulations.rds")

perform_inference <- FALSE
inference_file <- here("outputs/08_ppstat/inference.rds")
```

## Create true model

```{r}
# Times vector
times <- seq(0, duration_days, by = stepfunc)

# Create species names
spp_names <- paste0("s", 1:nspecies)
```

### Interaction function

```{r}
b <- -1/t*log(1/strength*log((exp(strength)+1)/2))

fs <- strength*exp(-b*times)
```


```{r}
#| code-fold: true

dat <- data.frame(t = times,
                  f = fs)

ggplot(dat) + geom_line(aes(x = t, y = f)) +
  ggtitle(paste0("True interaction log-function (strength = ", strength, ")")) +
  theme_linedraw() +
  geom_hline(yintercept = strength/2, linetype = "dashed") +
  geom_vline(xintercept = t, linetype = "dashed") +
  geom_hline(yintercept = 0) +
  xlab("Time (days)") +
  ylab(expression(paste("Intensity (", day^{-1}, ")")))
```

```{r}
#| code-fold: true
dat <- data.frame(t = times,
                  f = exp(fs))

mid <- (exp(strength)+1)/2

ggplot(dat) + geom_line(aes(x = t, y = f)) +
  ggtitle(paste0("True interaction function (strength = ", exp(strength), ")")) +
  theme_linedraw() +
  geom_hline(yintercept = mid, linetype = "dashed") +
  geom_vline(xintercept = t, linetype = "dashed") +
  geom_hline(yintercept = 1) +
  xlab("Time (days)") +
  ylab(expression(paste("Intensity (", day^{-1}, ")")))
```

### Background rate

If we could include a non-constant background rate, it would probably look like this:

```{r}
#| code-fold: true
hour_rad <- seq(0, 2*pi, by = 0.01)
background_rate <- log((strength/2)*sin(hour_rad) + strength)

br_df <- data.frame(rad = hour_rad,
                    hour = hour_rad*(24/(2*pi)),
                    rate = background_rate,
                    rate_exp = exp(background_rate))

# ggplot(br_df) + geom_line(aes(x = hour, y = rate)) +
#   theme_linedraw() +
#   geom_hline(yintercept = 0) +
#   geom_hline(yintercept = a, linetype = "dashed") +
#   scale_x_continuous(limits = c(0, 24), breaks = seq(0, 24, by = 6)) +
#   xlab("Time (days)") +
#   ylab(expression(paste("Log-intensity (", day^{-1}, ")")))

ggplot(br_df) + geom_line(aes(x = hour, y = rate_exp)) +
  theme_linedraw() +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = strength, linetype = "dashed") +
  scale_x_continuous(limits = c(0, 24), breaks = seq(0, 24, by = 6)) +
  xlab("Time (days)") +
  ylab(expression(paste("Intensity (", day^{-1}, ")")))
```


### Define the interaction network

```{r}
# ppstat doc:
# The list h is a list of lists with h[[m]][[k]] a vector containing the effect of the k'th process on the m'th process.

# Create empty interactions
interac <- create_interactions_ppstat(spp_names = spp_names, 
                                      times = times)

# Fill non zero interactions
interac[["s2"]][["s1"]] <- fs
interac[["s3"]][["s2"]] <- fs
interac[["s4"]][["s2"]] <- fs
```

```{r}
#| code-fold: true

# Transform data to graph
mat <- matrix(nrow = nspecies, ncol = nspecies)
colnames(mat) <- spp_names
rownames(mat) <- spp_names

for(j in 1:length(interac)) {
  weight <- sapply(interac[[j]], sum)
  
  mat[, j] <- weight
}

g <- igraph::graph.adjacency(mat, weighted = TRUE, 
                             mode = "directed")

g <- as_tbl_graph(g) %>% 
  activate(nodes) |> 
  rename("names" = "name")

lay <- layout_as_tree(g)
plot_graph(g,
           layout = lay,
           textsize = 6, 
           s = 12) + 
  ggtitle("True interaction network")
```

## Perform simulations

```{r}
lbd <- hawkesRate(h = interac,
                  Delta = times[2] - times[1],
                  beta0 = rep(spont, nspecies),
                  A = duration_days,
                  phi = exp)
```

```{r}
simnames <- paste0("s", 1:nrep_each)

simul_list <- vector(mode = "list", 
                     length = nrep_each)

if (perform_simu) {
  for (rep in 1:nrep_each) {
    print(paste("Simu: repetition", rep))
    sim <- data.frame()
    for(cam in 1:n_cameras) {
      sim_cam <- Ogata(tLim = Tmax, n = 5000, lambda = lbd)
      sim_cam$camera <- paste0("C", cam)
      
      sim <- rbind(sim, sim_cam)
    }
    simul_list[[rep]] <- sim
  }
  
  names(simul_list) <- simnames

  saveRDS(simul_list,
          simu_file)
} else {
  simul_list <- readRDS(simu_file)
}
```

```{r}
# Check one repetition
simul_list[[1]] |> 
  group_by(markType, camera) |> 
  summarize(n = n(), .groups = "drop") |> 
  group_by(markType) |> 
  summarize(mean = mean(n),
            sd = sd(n), .groups = "drop")
```


## Perform inference

```{r}
# Write formula
spp_names_formula <- paste0("M", seq(1:nspecies))
(f <- write_formula(spp = spp_names_formula, 
                    startknot_spp = startknot_spp, endknot_spp = endknot_spp, 
                    by_spp = by_spp,
                    ord = ord, 
                    trunc = trunc,
                    hourcov = FALSE))
```

```{r}
trans <- "exp"
```

```{r}
# Infer each repetition
infer_list <- vector(mode = "list", 
                     length = nrep_each)

if (perform_inference) {
  for(rep in 1:nrep_each) {
    print(paste("Inference: repetition", rep))
    sim <- simul_list[[rep]]
    
    # Format data
    sim$markType <- factor(sim$markType)
    sim$camera <- factor(sim$camera)
    
    # Create marked point process object
    p <- markedPointProcess(pointData = sim,
                            idVar = 'camera')
    
    # Infer model
    m <- pointProcessModel(as.formula(f),
                           data = p,
                           family = ppstat::Hawkes(phi),
                           N = Nbasis,
                           support = ndays)
    
    # Transform model
    mod_df <- getPlotData(m, alpha = 0.05, trans = trans)
    
    # Change variables names
    mod_df <- mod_df |> 
      mutate(response = gsub(response, 
                             pattern = "^M", replacement = "s")) |> 
      mutate(variable = gsub(variable, 
                             pattern = "^M", replacement = "s"))
    mod_df <- mod_df |> 
    rename("time" = "x",
           "excitefunc" = "value",
           "to" = "response",
           "from" = "variable")
    
    infer_list[[rep]] <- mod_df
  }
  
  names(infer_list) <- simnames
  
  saveRDS(infer_list,
          inference_file)
} else {
  infer_list <- readRDS(inference_file)
}

```

## Check inferred parameters values

```{r}
alpha <- 0.05

yintercept <- ifelse(is.null(trans),
                     0, do.call(trans, list(0)))
```

### Pick one repetition

```{r}
mod <- infer_list[[1]]
```

```{r, fig.width=6, fig.height=4}
#| code-fold: true
plot_interactions(mod, 
                  scale = "hours",
                  textsize = 9, 
                  timestep = 12,
                  baseline = yintercept,
                  line_geom = "line",
                  confint = c("cf.lower", "cf.upper"),
                  alpha_conf = 0.7)

# ggsave(file.path(figures_path, "test.jpeg"),
#        bg = "white",
#        width =  6, height = 4,
#        dpi = 600,
#        device = grDevices::jpeg)
```


### Compare true and inferred models

```{r}
# Transform true model
true_df <- lapply(seq_along(interac), 
                  function(i) lapply(seq_along(interac[[i]]), 
                                     function(j) data.frame(time = times, from = names(interac[[i]])[j], excitefunc = interac[[i]][[j]], to = names(interac)[i])))

true_df <- unlist(true_df, recursive = FALSE)
true_df <- do.call("rbind", true_df)

true_df <- true_df |> 
  mutate(cf.lower = NA, cf.upper = NA, .before = to) |> 
  mutate(rep = "true")
true_df <- true_df |> 
  mutate(excitefunc = do.call(trans, list(excitefunc)))
```

```{r}
infer_df <- lapply(seq_along(infer_list), 
                   function(i) infer_list[[i]] |> mutate(rep = names(infer_list)[i]))
infer_df <- do.call("rbind", infer_df)

plot_df <- true_df |> bind_rows(infer_df)
```

```{r}
plot_df <- plot_df |> 
  mutate(to = paste0("italic(", str_replace(to, "\\d", "[\\0]"), ")"),
         from = paste0("italic(", str_replace(from, "\\d", "[\\0]"), ")"))
```

```{r}
#| code-fold: true
plot_interactions_simu(plot_df,
                       baseline = yintercept,
                       timestep = 0.5,
                       textsize = 9, 
                       alpha_conf = 0.7,
                       parse = TRUE,
                       y_angle = 0,
                       col_baseline = "grey50",
                       conf = "confint",
                       # conf = "sample",
                       show.legend = TRUE,
                       line_geom = "line")

# Export plot
ggsave(file.path(figures_path, "inference_ppstat_simu.jpeg"),
       bg = "white",
       width =  6, height = 5,
       dpi = 600,
       device = grDevices::jpeg)
```

